{
	"methods": {
		"approve(address,uint256)": {
			"notice": "The zero address indicates there is no approved address. Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner."
		},
		"balanceOf(address)": {
			"notice": "Count all NFTs assigned to an owner."
		},
		"getApproved(uint256)": {
			"notice": "Throws if `_tokenId` is not a valid NFT."
		},
		"isApprovedForAll(address,address)": {
			"notice": "Query if an address is an authorized operator for another address."
		},
		"ownerOf(uint256)": {
			"notice": "Find the owner of an NFT."
		},
		"safeTransferFrom(address,address,uint256)": {
			"notice": "This works identically to the other function with an extra data parameter, except this function just sets data to \"\""
		},
		"safeTransferFrom(address,address,uint256,bytes)": {
			"notice": "Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received` on `_to` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`."
		},
		"setApprovalForAll(address,bool)": {
			"notice": "The contract MUST allow multiple operators per owner."
		},
		"transferFrom(address,address,uint256)": {
			"notice": "The caller is responsible to confirm that `_to` is capable of receiving NFTs or else they may be permanently lost."
		}
	}
}